\hypertarget{classServer_1_1Handler}{}\doxysection{Server\+::Handler Class Reference}
\label{classServer_1_1Handler}\index{Server::Handler@{Server::Handler}}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classServer_1_1Handler_ac17ef47fefb1dd8744f0e82f17766aeb}{Handler}} (int R\+W\+Backlog=1)
\begin{DoxyCompactList}\small\item\em Construct a new Server\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}}\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classServer_1_1Handler_af3c0415c3837f31286945f41d676873f}{$\sim$\+Handler}} ()
\begin{DoxyCompactList}\small\item\em Destroy the Server\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}}\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}} object. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classServer_1_1Handler_a74fcaee2dc94838d68a4ccdaaedff9a1}{commap\+\_\+init}} (void)
\begin{DoxyCompactList}\small\item\em Init map which contains command as string (key) and function pointer as value , which will be implicitly called when according command was called. \end{DoxyCompactList}\item 
void $\ast$ \mbox{\hyperlink{classServer_1_1Handler_a20b4fdfeab72ec9159e3ae6583f9e96a}{writer}} (int sfd, uint32\+\_\+t tid)
\begin{DoxyCompactList}\small\item\em Function that will be called in function intended for handling socket-\/writing stuff, and will be called in separate thread \+: simultieanously. \end{DoxyCompactList}\item 
void $\ast$ \mbox{\hyperlink{classServer_1_1Handler_a4c8ac65f097ab75fb7b6a79aa867fa90}{reader}} (int sfd, uint32\+\_\+t tid)
\begin{DoxyCompactList}\small\item\em Function that will be called in function intended for handling socket-\/reading stuff, and will be called in separate thread \+: semultieanously. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a9eda93c6451e3bd29f0a784152e8ebd4}{response\+\_\+to\+\_\+customer\+\_\+sign\+\_\+up}} (int sfd, const std\+::string \&)
\begin{DoxyCompactList}\small\item\em Send response to client in order to give to the client an information about log\+\_\+in (reject or accept request) \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a8c9e735a78519a372488996e784816d8}{response\+\_\+to\+\_\+user\+\_\+login}} (int sfd, const std\+::string \&)
\begin{DoxyCompactList}\small\item\em Send response to client in order to give to the client an information about sign\+\_\+up (reject or accept request) \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_aeabd568fe2c2a12afb702047c6425b50}{sign\+\_\+new\+\_\+customer}} (int sfd, const std\+::string \&)
\begin{DoxyCompactList}\small\item\em Send \$\+S\+I\+G\+N\+\_\+\+U\+P\+\_\+\+C\+O\+M\+M\+A\+ND command with corresponding credentials to server in order to sign up as new customer. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a3aeed904ace0ab03d78284184555a2c6}{log\+\_\+in\+\_\+to\+\_\+system}} (int sfd, const std\+::string \&)
\begin{DoxyCompactList}\small\item\em Send \$\+L\+O\+G\+\_\+\+I\+N\+\_\+\+C\+O\+M\+M\+A\+ND command in with corresponding credentials in order to log in as existing user. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a1fdd5de294f4424d44e8134797b3c974}{provide\+\_\+write\+\_\+thread}} (int sfd, const std\+::string \&)
\begin{DoxyCompactList}\small\item\em provide new socket a writ -\/ support with separate thread \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_ab20dce8c55011738c9f28da756db5274}{provide\+\_\+read\+\_\+thread}} (int sfd, const std\+::string \&)
\begin{DoxyCompactList}\small\item\em provide new socket a read -\/ support with separate thread \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_afc80454d811f1cac93be4b18154ba99f}{terminate\+\_\+socket}} (int sfd, const std\+::string \&)
\begin{DoxyCompactList}\small\item\em close connected socket passed as parameter \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a52220f73f662dc0590a5da4bf47418de}{cleanup\+\_\+socket\+\_\+garbage}} (int sfd)
\begin{DoxyCompactList}\small\item\em Clean threads if such exist in writer / reader containers. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a5758bf3d077ffe0493919a197d6b4a7a}{cleanup\+\_\+reader\+\_\+thread\+\_\+for\+\_\+socket}} (int sfd)
\begin{DoxyCompactList}\small\item\em clean reader threads provided for given socket \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a3d2a5082c3df28302917e443cd0c51ce}{cleanup\+\_\+writer\+\_\+thread\+\_\+for\+\_\+socket}} (int sfd)
\begin{DoxyCompactList}\small\item\em clean writer threads provided for given socket \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classServer_1_1Handler_a6df5e4fb7c14cf6b9ae3e8d2a9864626}{find\+\_\+in\+\_\+customer\+\_\+cache}} (const std\+::string \&unique\+\_\+token)
\begin{DoxyCompactList}\small\item\em Request DB or local tmp cache in order to find according user by particular credentials. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
decltype(\&\mbox{\hyperlink{classServer_1_1Handler_a1fdd5de294f4424d44e8134797b3c974}{Server\+::\+Handler\+::provide\+\_\+write\+\_\+thread}}) \mbox{\hyperlink{classServer_1_1Handler_a915b85749446641839ded8827ceb3645}{get\+\_\+command}} (std\+::string command)
\begin{DoxyCompactList}\small\item\em Return according handler-\/function pointer based on passed command name these bindings are stored in associative containers. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classServer_1_1Handler_ac17ef47fefb1dd8744f0e82f17766aeb}\label{classServer_1_1Handler_ac17ef47fefb1dd8744f0e82f17766aeb}} 
\index{Server::Handler@{Server::Handler}!Handler@{Handler}}
\index{Handler@{Handler}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{Handler()}{Handler()}}
{\footnotesize\ttfamily Server\+::\+Handler\+::\+Handler (\begin{DoxyParamCaption}\item[{int}]{R\+W\+Backlog = {\ttfamily 1} }\end{DoxyParamCaption})}



Construct a new Server\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}}\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}} object. 


\begin{DoxyParams}{Parameters}
{\em R\+W\+Beacklog} & represents number of allowed thread count to use reader \& writer function at the same time \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classServer_1_1Handler_af3c0415c3837f31286945f41d676873f}\label{classServer_1_1Handler_af3c0415c3837f31286945f41d676873f}} 
\index{Server::Handler@{Server::Handler}!````~Handler@{$\sim$Handler}}
\index{````~Handler@{$\sim$Handler}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{$\sim$Handler()}{~Handler()}}
{\footnotesize\ttfamily Server\+::\+Handler\+::$\sim$\+Handler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Destroy the Server\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}}\+:\+: \mbox{\hyperlink{classServer_1_1Handler}{Handler}} object. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classServer_1_1Handler_a5758bf3d077ffe0493919a197d6b4a7a}\label{classServer_1_1Handler_a5758bf3d077ffe0493919a197d6b4a7a}} 
\index{Server::Handler@{Server::Handler}!cleanup\_reader\_thread\_for\_socket@{cleanup\_reader\_thread\_for\_socket}}
\index{cleanup\_reader\_thread\_for\_socket@{cleanup\_reader\_thread\_for\_socket}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{cleanup\_reader\_thread\_for\_socket()}{cleanup\_reader\_thread\_for\_socket()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::cleanup\+\_\+reader\+\_\+thread\+\_\+for\+\_\+socket (\begin{DoxyParamCaption}\item[{int}]{sfd }\end{DoxyParamCaption})}



clean reader threads provided for given socket 


\begin{DoxyParams}{Parameters}
{\em sfd} & socket which reader trheads will be killed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 for success 1 on failure 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a52220f73f662dc0590a5da4bf47418de}\label{classServer_1_1Handler_a52220f73f662dc0590a5da4bf47418de}} 
\index{Server::Handler@{Server::Handler}!cleanup\_socket\_garbage@{cleanup\_socket\_garbage}}
\index{cleanup\_socket\_garbage@{cleanup\_socket\_garbage}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{cleanup\_socket\_garbage()}{cleanup\_socket\_garbage()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::cleanup\+\_\+socket\+\_\+garbage (\begin{DoxyParamCaption}\item[{int}]{sfd }\end{DoxyParamCaption})}



Clean threads if such exist in writer / reader containers. 


\begin{DoxyParams}{Parameters}
{\em sfd} & to clean after \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int success code 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a3d2a5082c3df28302917e443cd0c51ce}\label{classServer_1_1Handler_a3d2a5082c3df28302917e443cd0c51ce}} 
\index{Server::Handler@{Server::Handler}!cleanup\_writer\_thread\_for\_socket@{cleanup\_writer\_thread\_for\_socket}}
\index{cleanup\_writer\_thread\_for\_socket@{cleanup\_writer\_thread\_for\_socket}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{cleanup\_writer\_thread\_for\_socket()}{cleanup\_writer\_thread\_for\_socket()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::cleanup\+\_\+writer\+\_\+thread\+\_\+for\+\_\+socket (\begin{DoxyParamCaption}\item[{int}]{sfd }\end{DoxyParamCaption})}



clean writer threads provided for given socket 


\begin{DoxyParams}{Parameters}
{\em sfd} & socket which reader trheads will be killed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 for success 1 on failure 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a74fcaee2dc94838d68a4ccdaaedff9a1}\label{classServer_1_1Handler_a74fcaee2dc94838d68a4ccdaaedff9a1}} 
\index{Server::Handler@{Server::Handler}!commap\_init@{commap\_init}}
\index{commap\_init@{commap\_init}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{commap\_init()}{commap\_init()}}
{\footnotesize\ttfamily void Server\+::\+Handler\+::commap\+\_\+init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Init map which contains command as string (key) and function pointer as value , which will be implicitly called when according command was called. 

\begin{DoxyNote}{Note}
this function values must be member functions or implicitly been derived from class type \mbox{\hyperlink{classServer_1_1Handler}{Server\+::\+Handler}} ptr type \+: int (\mbox{\hyperlink{classServer_1_1Handler}{Server\+::\+Handler}}\+:\+:$\ast$)(int) 
\end{DoxyNote}
\mbox{\Hypertarget{classServer_1_1Handler_a6df5e4fb7c14cf6b9ae3e8d2a9864626}\label{classServer_1_1Handler_a6df5e4fb7c14cf6b9ae3e8d2a9864626}} 
\index{Server::Handler@{Server::Handler}!find\_in\_customer\_cache@{find\_in\_customer\_cache}}
\index{find\_in\_customer\_cache@{find\_in\_customer\_cache}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{find\_in\_customer\_cache()}{find\_in\_customer\_cache()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::find\+\_\+in\+\_\+customer\+\_\+cache (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{unique\+\_\+token }\end{DoxyParamCaption})}



Request DB or local tmp cache in order to find according user by particular credentials. 


\begin{DoxyParams}{Parameters}
{\em unique\+\_\+token} & Particular unique credential \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a3aeed904ace0ab03d78284184555a2c6}\label{classServer_1_1Handler_a3aeed904ace0ab03d78284184555a2c6}} 
\index{Server::Handler@{Server::Handler}!log\_in\_to\_system@{log\_in\_to\_system}}
\index{log\_in\_to\_system@{log\_in\_to\_system}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{log\_in\_to\_system()}{log\_in\_to\_system()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::log\+\_\+in\+\_\+to\+\_\+system (\begin{DoxyParamCaption}\item[{int}]{sfd,  }\item[{const std\+::string \&}]{ }\end{DoxyParamCaption})}



Send \$\+L\+O\+G\+\_\+\+I\+N\+\_\+\+C\+O\+M\+M\+A\+ND command in with corresponding credentials in order to log in as existing user. 


\begin{DoxyParams}{Parameters}
{\em sfd} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_ab20dce8c55011738c9f28da756db5274}\label{classServer_1_1Handler_ab20dce8c55011738c9f28da756db5274}} 
\index{Server::Handler@{Server::Handler}!provide\_read\_thread@{provide\_read\_thread}}
\index{provide\_read\_thread@{provide\_read\_thread}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{provide\_read\_thread()}{provide\_read\_thread()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::provide\+\_\+read\+\_\+thread (\begin{DoxyParamCaption}\item[{int}]{new\+\_\+read\+\_\+socket,  }\item[{const std\+::string \&}]{ }\end{DoxyParamCaption})}



provide new socket a read -\/ support with separate thread 


\begin{DoxyParams}{Parameters}
{\em new\+\_\+read\+\_\+socket} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 1 on opposite result 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a1fdd5de294f4424d44e8134797b3c974}\label{classServer_1_1Handler_a1fdd5de294f4424d44e8134797b3c974}} 
\index{Server::Handler@{Server::Handler}!provide\_write\_thread@{provide\_write\_thread}}
\index{provide\_write\_thread@{provide\_write\_thread}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{provide\_write\_thread()}{provide\_write\_thread()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::provide\+\_\+write\+\_\+thread (\begin{DoxyParamCaption}\item[{int}]{new\+\_\+write\+\_\+socket,  }\item[{const std\+::string \&}]{ }\end{DoxyParamCaption})}



provide new socket a writ -\/ support with separate thread 


\begin{DoxyParams}{Parameters}
{\em new\+\_\+write\+\_\+socket} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 1 on opposite result 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a4c8ac65f097ab75fb7b6a79aa867fa90}\label{classServer_1_1Handler_a4c8ac65f097ab75fb7b6a79aa867fa90}} 
\index{Server::Handler@{Server::Handler}!reader@{reader}}
\index{reader@{reader}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{reader()}{reader()}}
{\footnotesize\ttfamily void $\ast$ Server\+::\+Handler\+::reader (\begin{DoxyParamCaption}\item[{int}]{sfd,  }\item[{uint32\+\_\+t}]{tid }\end{DoxyParamCaption})}



Function that will be called in function intended for handling socket-\/reading stuff, and will be called in separate thread \+: semultieanously. 


\begin{DoxyParams}{Parameters}
{\em param} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a9eda93c6451e3bd29f0a784152e8ebd4}\label{classServer_1_1Handler_a9eda93c6451e3bd29f0a784152e8ebd4}} 
\index{Server::Handler@{Server::Handler}!response\_to\_customer\_sign\_up@{response\_to\_customer\_sign\_up}}
\index{response\_to\_customer\_sign\_up@{response\_to\_customer\_sign\_up}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{response\_to\_customer\_sign\_up()}{response\_to\_customer\_sign\_up()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::response\+\_\+to\+\_\+customer\+\_\+sign\+\_\+up (\begin{DoxyParamCaption}\item[{int}]{sfd,  }\item[{const std\+::string \&}]{ }\end{DoxyParamCaption})}



Send response to client in order to give to the client an information about log\+\_\+in (reject or accept request) 


\begin{DoxyParams}{Parameters}
{\em sfd} & connection descriptor \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 1 otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a8c9e735a78519a372488996e784816d8}\label{classServer_1_1Handler_a8c9e735a78519a372488996e784816d8}} 
\index{Server::Handler@{Server::Handler}!response\_to\_user\_login@{response\_to\_user\_login}}
\index{response\_to\_user\_login@{response\_to\_user\_login}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{response\_to\_user\_login()}{response\_to\_user\_login()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::response\+\_\+to\+\_\+user\+\_\+login (\begin{DoxyParamCaption}\item[{int}]{sfd,  }\item[{const std\+::string \&}]{ }\end{DoxyParamCaption})}



Send response to client in order to give to the client an information about sign\+\_\+up (reject or accept request) 


\begin{DoxyParams}{Parameters}
{\em sfd} & connection descriptor \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 1 otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_aeabd568fe2c2a12afb702047c6425b50}\label{classServer_1_1Handler_aeabd568fe2c2a12afb702047c6425b50}} 
\index{Server::Handler@{Server::Handler}!sign\_new\_customer@{sign\_new\_customer}}
\index{sign\_new\_customer@{sign\_new\_customer}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{sign\_new\_customer()}{sign\_new\_customer()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::sign\+\_\+new\+\_\+customer (\begin{DoxyParamCaption}\item[{int}]{sfd,  }\item[{const std\+::string \&}]{ }\end{DoxyParamCaption})}



Send \$\+S\+I\+G\+N\+\_\+\+U\+P\+\_\+\+C\+O\+M\+M\+A\+ND command with corresponding credentials to server in order to sign up as new customer. 


\begin{DoxyParams}{Parameters}
{\em sfd} & connection descriptor \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 1 otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_afc80454d811f1cac93be4b18154ba99f}\label{classServer_1_1Handler_afc80454d811f1cac93be4b18154ba99f}} 
\index{Server::Handler@{Server::Handler}!terminate\_socket@{terminate\_socket}}
\index{terminate\_socket@{terminate\_socket}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{terminate\_socket()}{terminate\_socket()}}
{\footnotesize\ttfamily int Server\+::\+Handler\+::terminate\+\_\+socket (\begin{DoxyParamCaption}\item[{int}]{sfd,  }\item[{const std\+::string \&}]{ }\end{DoxyParamCaption})}



close connected socket passed as parameter 


\begin{DoxyParams}{Parameters}
{\em sfd} & socket to close \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
close success code 
\end{DoxyReturn}
\mbox{\Hypertarget{classServer_1_1Handler_a20b4fdfeab72ec9159e3ae6583f9e96a}\label{classServer_1_1Handler_a20b4fdfeab72ec9159e3ae6583f9e96a}} 
\index{Server::Handler@{Server::Handler}!writer@{writer}}
\index{writer@{writer}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{writer()}{writer()}}
{\footnotesize\ttfamily void $\ast$ Server\+::\+Handler\+::writer (\begin{DoxyParamCaption}\item[{int}]{sfd,  }\item[{uint32\+\_\+t}]{tid }\end{DoxyParamCaption})}



Function that will be called in function intended for handling socket-\/writing stuff, and will be called in separate thread \+: simultieanously. 


\begin{DoxyParams}{Parameters}
{\em param} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void$\ast$ 
\end{DoxyReturn}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classServer_1_1Handler_a915b85749446641839ded8827ceb3645}\label{classServer_1_1Handler_a915b85749446641839ded8827ceb3645}} 
\index{Server::Handler@{Server::Handler}!get\_command@{get\_command}}
\index{get\_command@{get\_command}!Server::Handler@{Server::Handler}}
\doxysubsubsection{\texorpdfstring{get\_command}{get\_command}}
{\footnotesize\ttfamily decltype(\&) \mbox{\hyperlink{classServer_1_1Handler_a1fdd5de294f4424d44e8134797b3c974}{Server\+::\+Handler\+::provide\+\_\+write\+\_\+thread}} Server\+::\+Handler\+::get\+\_\+command}



Return according handler-\/function pointer based on passed command name these bindings are stored in associative containers. 


\begin{DoxyParams}{Parameters}
{\em command} & string indroduction of command \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
decltype (\&\mbox{\hyperlink{classServer_1_1Handler_a1fdd5de294f4424d44e8134797b3c974}{Server\+::\+Handler\+::provide\+\_\+write\+\_\+thread}}) 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/server/include/\mbox{\hyperlink{handler_8h}{handler.\+h}}\item 
src/server/src/handler.\+cpp\end{DoxyCompactItemize}
